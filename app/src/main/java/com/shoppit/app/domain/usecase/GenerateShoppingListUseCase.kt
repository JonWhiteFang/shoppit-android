package com.shoppit.app.domain.usecase

import com.shoppit.app.domain.model.Ingredient
import com.shoppit.app.domain.model.ItemCategory
import com.shoppit.app.domain.model.Meal
import com.shoppit.app.domain.model.MealPlan
import com.shoppit.app.domain.model.ShoppingListItem
import com.shoppit.app.domain.repository.MealPlanRepository
import com.shoppit.app.domain.repository.MealRepository
import com.shoppit.app.domain.repository.ShoppingListRepository
import com.shoppit.app.util.Logger
import kotlinx.coroutines.flow.first
import java.time.DayOfWeek
import java.time.LocalDate
import javax.inject.Inject

/**
 * Use case for generating a shopping list from the current week's meal plans.
 * Aggregates ingredients from all planned meals, categorizes them, and creates
 * shopping list items. Replaces existing auto-generated items.
 */
class GenerateShoppingListUseCase @Inject constructor(
    private val shoppingListRepository: ShoppingListRepository,
    private val mealPlanRepository: MealPlanRepository,
    private val mealRepository: MealRepository
) {
    /**
     * Generates a shopping list from the current week's meal plans.
     * 
     * @return Result indicating success or error
     */
    suspend operator fun invoke(): Result<Unit> {
        // Get current week's meal plans (Monday to Sunday)
        val startDate = LocalDate.now().with(DayOfWeek.MONDAY)
        val endDate = startDate.plusDays(6)
        
        return try {
            Logger.d(TAG, "Generating shopping list for week: $startDate to $endDate")
            
            mealPlanRepository.getMealPlansForWeek(startDate, endDate)
                .first()
                .flatMap { mealPlans ->
                    // Handle empty meal plans
                    if (mealPlans.isEmpty()) {
                        Logger.d(TAG, "No meal plans found for the week")
                        // Still delete auto-generated items and return success
                        return@flatMap shoppingListRepository.deleteAutoGeneratedItems()
                    }
                    
                    // Get all unique meal IDs
                    val mealIds = mealPlans.map { it.mealId }.distinct()
                    Logger.d(TAG, "Found ${mealPlans.size} meal plans with ${mealIds.size} unique meals")
                    
                    // Get meal details
                    mealRepository.getMeals().first().flatMap { meals ->
                        val mealMap = meals.associateBy { it.id }
                        
                        // Aggregate ingredients
                        val aggregatedItems = aggregateIngredients(mealPlans, mealMap)
                        Logger.d(TAG, "Aggregated ${aggregatedItems.size} shopping list items")
                        
                        // Delete existing auto-generated items
                        shoppingListRepository.deleteAutoGeneratedItems().flatMap {
                            // Add new items
                            shoppingListRepository.addShoppingListItems(aggregatedItems)
                                .map { 
                                    Logger.d(TAG, "Successfully generated shopping list")
                                    Unit 
                                }
                        }
                    }
                }
        } catch (e: Exception) {
            Logger.e(TAG, "Failed to generate shopping list", e)
            Result.failure(e)
        }
    }
    
    /**
     * Aggregates ingredients from meal plans, grouping by name (case-insensitive).
     * Handles edge cases like empty ingredient lists and missing meals.
     * 
     * @param mealPlans List of meal plans for the week
     * @param mealMap Map of meal IDs to meal objects
     * @return List of aggregated shopping list items
     */
    private fun aggregateIngredients(
        mealPlans: List<MealPlan>,
        mealMap: Map<Long, Meal>
    ): List<ShoppingListItem> {
        // Group ingredients by name (case-insensitive)
        val ingredientGroups = mutableMapOf<String, MutableList<Pair<Ingredient, Long>>>()
        
        mealPlans.forEach { plan ->
            val meal = mealMap[plan.mealId]
            if (meal == null) {
                Logger.w(TAG, "Meal not found for plan: ${plan.id}, mealId: ${plan.mealId}")
                return@forEach
            }
            
            // Skip meals with no ingredients
            if (meal.ingredients.isEmpty()) {
                Logger.d(TAG, "Meal '${meal.name}' has no ingredients")
                return@forEach
            }
            
            meal.ingredients.forEach { ingredient ->
                // Skip ingredients with empty names
                if (ingredient.name.isBlank()) {
                    Logger.w(TAG, "Skipping ingredient with empty name in meal '${meal.name}'")
                    return@forEach
                }
                
                val key = ingredient.name.lowercase().trim()
                ingredientGroups.getOrPut(key) { mutableListOf() }
                    .add(ingredient to meal.id)
            }
        }
        
        // Create shopping list items
        return ingredientGroups.map { (_, ingredientPairs) ->
            val ingredients = ingredientPairs.map { it.first }
            val mealIds = ingredientPairs.map { it.second }.distinct()
            val firstIngredient = ingredients.first()
            
            // Aggregate quantities
            val aggregatedQuantity = if (ingredients.size == 1) {
                firstIngredient.quantity
            } else {
                ingredients.joinToString(" + ") { it.quantity }
            }
            
            ShoppingListItem(
                name = firstIngredient.name,
                quantity = aggregatedQuantity,
                unit = firstIngredient.unit,
                category = categorizeIngredient(firstIngredient.name),
                isManual = false,
                mealIds = mealIds
            )
        }
    }
    
    /**
     * Categorizes an ingredient based on keyword matching.
     * 
     * @param name The ingredient name
     * @return The appropriate ItemCategory
     */
    private fun categorizeIngredient(name: String): ItemCategory {
        val lowerName = name.lowercase()
        return when {
            lowerName in produceKeywords -> ItemCategory.PRODUCE
            lowerName in dairyKeywords -> ItemCategory.DAIRY
            lowerName in meatKeywords -> ItemCategory.MEAT
            lowerName in pantryKeywords -> ItemCategory.PANTRY
            else -> ItemCategory.OTHER
        }
    }
    
    companion object {
        private const val TAG = "GenerateShoppingListUseCase"
        
        private val produceKeywords = setOf(
            "lettuce", "tomato", "onion", "garlic", "potato", "carrot",
            "celery", "pepper", "cucumber", "spinach", "broccoli", "apple",
            "banana", "orange", "lemon", "lime", "avocado", "mushroom"
        )
        
        private val dairyKeywords = setOf(
            "milk", "cheese", "butter", "cream", "yogurt", "sour cream",
            "cottage cheese", "mozzarella", "parmesan", "cheddar"
        )
        
        private val meatKeywords = setOf(
            "chicken", "beef", "pork", "fish", "salmon", "tuna", "shrimp",
            "turkey", "bacon", "sausage", "ham", "lamb", "steak"
        )
        
        private val pantryKeywords = setOf(
            "flour", "sugar", "salt", "pepper", "oil", "rice", "pasta",
            "bread", "cereal", "oats", "beans", "sauce", "vinegar", "spice"
        )
    }
}
