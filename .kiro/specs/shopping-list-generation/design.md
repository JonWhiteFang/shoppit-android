# Design Document

## Overview

The Shopping List Generation feature automatically creates and maintains a shopping list by aggregating ingredients from all meals in the user's weekly meal plan. The design follows Clean Architecture principles with an offline-first approach using Room database, reactive data flow with Kotlin Flow, and automatic synchronization when meal plans change. This feature provides the final piece of the meal planning workflow, enabling users to seamlessly transition from planning to shopping.

## Architecture

### Layer Structure

```
com.shoppit.app/
├── ui/
│   └── shopping/
│       ├── ShoppingListScreen.kt              # Main shopping list view
│       ├── ShoppingListViewModel.kt           # State management
│       ├── ShoppingListUiState.kt             # UI state definitions
│       ├── AddItemDialog.kt                   # Manual item input
│       └── ItemDetailDialog.kt                # Ingredient source details
├── domain/
│   ├── model/
│   │   ├── ShoppingListItem.kt                # Domain shopping list item
│   │   ├── ItemCategory.kt                    # Category enumeration
│   │   └── IngredientSource.kt                # Meal source tracking
│   ├── repository/
│   │   └── ShoppingListRepository.kt          # Repository interface
│   └── usecase/
│       ├── GenerateShoppingListUseCase.kt     # Auto-generate from plans
│       ├── GetShoppingListUseCase.kt          # Retrieve current list
│       ├── ToggleItemCheckedUseCase.kt        # Check/uncheck item
│       ├── AddManualItemUseCase.kt            # Add manual item
│       ├── UpdateManualItemUseCase.kt         # Edit manual item
│       ├── DeleteManualItemUseCase.kt         # Remove manual item
│       ├── ClearCheckedItemsUseCase.kt        # Remove checked items
│       ├── UncheckAllItemsUseCase.kt          # Reset all to unchecked
│       └── GetItemSourcesUseCase.kt           # Get meals for ingredient
└── data/
    ├── local/
    │   ├── entity/
    │   │   └── ShoppingListItemEntity.kt      # Room entity
    │   ├── dao/
    │   │   └── ShoppingListDao.kt             # Data access object
    │   └── database/
    │       └── AppDatabase.kt                 # Updated with ShoppingListDao
    ├── repository/
    │   └── ShoppingListRepositoryImpl.kt      # Repository implementation
    └── mapper/
        └── ShoppingListMapper.kt              # Entity/model conversions
```

## Components and Interfaces

### 1. Domain Models

```kotlin
// Shopping list item with aggregated ingredient data
data class ShoppingListItem(
    val id: Long = 0,
    val name: String,
    val quantity: String,
    val unit: String,
    val category: ItemCategory,
    val isChecked: Boolean = false,
    val isManual: Boolean = false,
    val mealIds: List<Long> = emptyList(), // Meals using this ingredient
    val createdAt: Long = System.currentTimeMillis()
)

// Category for organizing shopping list
enum class ItemCategory {
    PRODUCE,
    DAIRY,
    MEAT,
    PANTRY,
    OTHER;
    
    fun displayName(): String = when (this) {
        PRODUCE -> "Produce"
        DAIRY -> "Dairy"
        MEAT -> "Meat & Seafood"
        PANTRY -> "Pantry"
        OTHER -> "Other"
    }
}

// Tracks which meals use an ingredient
data class IngredientSource(
    val mealId: Long,
    val mealName: String,
    val quantity: String,
    val unit: String
)

// Grouped shopping list data
data class ShoppingListData(
    val itemsByCategory: Map<ItemCategory, List<ShoppingListItem>>,
    val totalItems: Int,
    val checkedItems: Int
)
```

### 2. Repository Interface

```kotlin
interface ShoppingListRepository {
    // Reactive queries return Flow for real-time updates
    fun getShoppingList(): Flow<Result<List<ShoppingListItem>>>
    fun getShoppingListItem(id: Long): Flow<Result<ShoppingListItem>>
    
    // Mutations return Result for error handling
    suspend fun addShoppingListItem(item: ShoppingListItem): Result<Long>
    suspend fun addShoppingListItems(items: List<ShoppingListItem>): Result<List<Long>>
    suspend fun updateShoppingListItem(item: ShoppingListItem): Result<Unit>
    suspend fun deleteShoppingListItem(id: Long): Result<Unit>
    suspend fun deleteCheckedItems(): Result<Unit>
    suspend fun deleteAutoGeneratedItems(): Result<Unit>
    suspend fun uncheckAllItems(): Result<Unit>
}
```

### 3. Use Cases

```kotlin
// Generate shopping list from current week's meal plans
class GenerateShoppingListUseCase @Inject constructor(
    private val shoppingListRepository: ShoppingListRepository,
    private val mealPlanRepository: MealPlanRepository,
    private val mealRepository: MealRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        // Get current week's meal plans
        val startDate = LocalDate.now().with(DayOfWeek.MONDAY)
        val endDate = startDate.plusDays(6)
        
        return mealPlanRepository.getMealPlansForWeek(startDate, endDate)
            .first()
            .flatMap { mealPlans ->
                // Get all unique meal IDs
                val mealIds = mealPlans.map { it.mealId }.distinct()
                
                // Get meal details
                mealRepository.getMeals().first().flatMap { meals ->
                    val mealMap = meals.associateBy { it.id }
                    
                    // Aggregate ingredients
                    val aggregatedItems = aggregateIngredients(mealPlans, mealMap)
                    
                    // Delete existing auto-generated items
                    shoppingListRepository.deleteAutoGeneratedItems().flatMap {
                        // Add new items
                        shoppingListRepository.addShoppingListItems(aggregatedItems)
                            .map { Unit }
                    }
                }
            }
    }
    
    private fun aggregateIngredients(
        mealPlans: List<MealPlan>,
        mealMap: Map<Long, Meal>
    ): List<ShoppingListItem> {
        // Group ingredients by name (case-insensitive)
        val ingredientGroups = mutableMapOf<String, MutableList<Pair<Ingredient, Long>>>()
        
        mealPlans.forEach { plan ->
            mealMap[plan.mealId]?.let { meal ->
                meal.ingredients.forEach { ingredient ->
                    val key = ingredient.name.lowercase()
                    ingredientGroups.getOrPut(key) { mutableListOf() }
                        .add(ingredient to meal.id)
                }
            }
        }
        
        // Create shopping list items
        return ingredientGroups.map { (_, ingredientPairs) ->
            val ingredients = ingredientPairs.map { it.first }
            val mealIds = ingredientPairs.map { it.second }.distinct()
            val firstIngredient = ingredients.first()
            
            // Aggregate quantities
            val aggregatedQuantity = if (ingredients.size == 1) {
                firstIngredient.quantity
            } else {
                ingredients.joinToString(" + ") { it.quantity }
            }
            
            ShoppingListItem(
                name = firstIngredient.name,
                quantity = aggregatedQuantity,
                unit = firstIngredient.unit,
                category = categorizeIngredient(firstIngredient.name),
                isManual = false,
                mealIds = mealIds
            )
        }
    }
    
    private fun categorizeIngredient(name: String): ItemCategory {
        val lowerName = name.lowercase()
        return when {
            lowerName in produceKeywords -> ItemCategory.PRODUCE
            lowerName in dairyKeywords -> ItemCategory.DAIRY
            lowerName in meatKeywords -> ItemCategory.MEAT
            lowerName in pantryKeywords -> ItemCategory.PANTRY
            else -> ItemCategory.OTHER
        }
    }
    
    companion object {
        private val produceKeywords = setOf(
            "lettuce", "tomato", "onion", "garlic", "potato", "carrot",
            "celery", "pepper", "cucumber", "spinach", "broccoli", "apple",
            "banana", "orange", "lemon", "lime", "avocado", "mushroom"
        )
        
        private val dairyKeywords = setOf(
            "milk", "cheese", "butter", "cream", "yogurt", "sour cream",
            "cottage cheese", "mozzarella", "parmesan", "cheddar"
        )
        
        private val meatKeywords = setOf(
            "chicken", "beef", "pork", "fish", "salmon", "tuna", "shrimp",
            "turkey", "bacon", "sausage", "ham", "lamb", "steak"
        )
        
        private val pantryKeywords = setOf(
            "flour", "sugar", "salt", "pepper", "oil", "rice", "pasta",
            "bread", "cereal", "oats", "beans", "sauce", "vinegar", "spice"
        )
    }
}

// Get shopping list with real-time updates
class GetShoppingListUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    operator fun invoke(): Flow<Result<ShoppingListData>> {
        return repository.getShoppingList()
            .map { result ->
                result.map { items ->
                    val itemsByCategory = items.groupBy { it.category }
                    ShoppingListData(
                        itemsByCategory = itemsByCategory,
                        totalItems = items.size,
                        checkedItems = items.count { it.isChecked }
                    )
                }
            }
    }
}

// Toggle item checked status
class ToggleItemCheckedUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(itemId: Long, isChecked: Boolean): Result<Unit> {
        return repository.getShoppingListItem(itemId).first().flatMap { item ->
            val updatedItem = item.copy(isChecked = isChecked)
            repository.updateShoppingListItem(updatedItem)
        }
    }
}

// Add manual shopping list item
class AddManualItemUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(
        name: String,
        quantity: String,
        unit: String
    ): Result<Long> {
        if (name.isBlank()) {
            return Result.failure(ValidationException("Item name cannot be empty"))
        }
        
        val item = ShoppingListItem(
            name = name.trim(),
            quantity = quantity.trim(),
            unit = unit.trim(),
            category = ItemCategory.OTHER,
            isManual = true
        )
        
        return repository.addShoppingListItem(item)
    }
}

// Update manual shopping list item
class UpdateManualItemUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(
        itemId: Long,
        name: String,
        quantity: String,
        unit: String
    ): Result<Unit> {
        if (name.isBlank()) {
            return Result.failure(ValidationException("Item name cannot be empty"))
        }
        
        return repository.getShoppingListItem(itemId).first().flatMap { item ->
            if (!item.isManual) {
                return@flatMap Result.failure(
                    ValidationException("Cannot edit auto-generated items")
                )
            }
            
            val updatedItem = item.copy(
                name = name.trim(),
                quantity = quantity.trim(),
                unit = unit.trim()
            )
            repository.updateShoppingListItem(updatedItem)
        }
    }
}

// Delete manual shopping list item
class DeleteManualItemUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(itemId: Long): Result<Unit> {
        return repository.getShoppingListItem(itemId).first().flatMap { item ->
            if (!item.isManual) {
                return@flatMap Result.failure(
                    ValidationException("Cannot delete auto-generated items")
                )
            }
            repository.deleteShoppingListItem(itemId)
        }
    }
}

// Clear all checked items
class ClearCheckedItemsUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        return repository.deleteCheckedItems()
    }
}

// Uncheck all items
class UncheckAllItemsUseCase @Inject constructor(
    private val repository: ShoppingListRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        return repository.uncheckAllItems()
    }
}

// Get ingredient sources (which meals use it)
class GetItemSourcesUseCase @Inject constructor(
    private val mealRepository: MealRepository
) {
    suspend operator fun invoke(
        ingredientName: String,
        mealIds: List<Long>
    ): Result<List<IngredientSource>> {
        return mealRepository.getMeals().first().map { meals ->
            meals.filter { it.id in mealIds }
                .mapNotNull { meal ->
                    meal.ingredients.find { 
                        it.name.equals(ingredientName, ignoreCase = true) 
                    }?.let { ingredient ->
                        IngredientSource(
                            mealId = meal.id,
                            mealName = meal.name,
                            quantity = ingredient.quantity,
                            unit = ingredient.unit
                        )
                    }
                }
        }
    }
}
```

## Data Models

### Room Entities

```kotlin
@Entity(
    tableName = "shopping_list_items",
    indices = [
        Index(value = ["name"]),
        Index(value = ["is_manual"]),
        Index(value = ["is_checked"])
    ]
)
data class ShoppingListItemEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "quantity")
    val quantity: String,
    
    @ColumnInfo(name = "unit")
    val unit: String,
    
    @ColumnInfo(name = "category")
    val category: String, // PRODUCE, DAIRY, MEAT, PANTRY, OTHER
    
    @ColumnInfo(name = "is_checked")
    val isChecked: Boolean = false,
    
    @ColumnInfo(name = "is_manual")
    val isManual: Boolean = false,
    
    @ColumnInfo(name = "meal_ids")
    val mealIds: String, // Comma-separated meal IDs
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long
)
```

### Type Converters

```kotlin
// Add to existing Converters class
class Converters {
    // ... existing converters ...
    
    @TypeConverter
    fun fromMealIdList(value: List<Long>): String {
        return value.joinToString(",")
    }
    
    @TypeConverter
    fun toMealIdList(value: String): List<Long> {
        return if (value.isBlank()) {
            emptyList()
        } else {
            value.split(",").mapNotNull { it.toLongOrNull() }
        }
    }
}
```

### Data Access Object

```kotlin
@Dao
interface ShoppingListDao {
    @Query("SELECT * FROM shopping_list_items ORDER BY category ASC, name ASC")
    fun getAllItems(): Flow<List<ShoppingListItemEntity>>
    
    @Query("SELECT * FROM shopping_list_items WHERE id = :itemId")
    fun getItemById(itemId: Long): Flow<ShoppingListItemEntity?>
    
    @Query("SELECT * FROM shopping_list_items WHERE is_checked = 0 ORDER BY category ASC, name ASC")
    fun getUncheckedItems(): Flow<List<ShoppingListItemEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertItem(item: ShoppingListItemEntity): Long
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertItems(items: List<ShoppingListItemEntity>): List<Long>
    
    @Update
    suspend fun updateItem(item: ShoppingListItemEntity)
    
    @Query("UPDATE shopping_list_items SET is_checked = :isChecked WHERE id = :itemId")
    suspend fun updateCheckedStatus(itemId: Long, isChecked: Boolean)
    
    @Query("UPDATE shopping_list_items SET is_checked = 0")
    suspend fun uncheckAllItems()
    
    @Query("DELETE FROM shopping_list_items WHERE id = :itemId")
    suspend fun deleteItemById(itemId: Long)
    
    @Query("DELETE FROM shopping_list_items WHERE is_checked = 1")
    suspend fun deleteCheckedItems()
    
    @Query("DELETE FROM shopping_list_items WHERE is_manual = 0")
    suspend fun deleteAutoGeneratedItems()
    
    @Query("SELECT COUNT(*) FROM shopping_list_items")
    suspend fun getItemCount(): Int
    
    @Query("SELECT COUNT(*) FROM shopping_list_items WHERE is_checked = 1")
    suspend fun getCheckedItemCount(): Int
}
```

### Repository Implementation

```kotlin
class ShoppingListRepositoryImpl @Inject constructor(
    private val shoppingListDao: ShoppingListDao
) : ShoppingListRepository {
    
    override fun getShoppingList(): Flow<Result<List<ShoppingListItem>>> {
        return shoppingListDao.getAllItems()
            .map { entities -> 
                Result.success(entities.map { it.toDomainModel() })
            }
            .catch { e -> 
                emit(Result.failure(DatabaseException("Failed to load shopping list", e)))
            }
    }
    
    override fun getShoppingListItem(id: Long): Flow<Result<ShoppingListItem>> {
        return shoppingListDao.getItemById(id)
            .map { entity ->
                entity?.let { Result.success(it.toDomainModel()) }
                    ?: Result.failure(NotFoundException("Shopping list item not found"))
            }
            .catch { e ->
                emit(Result.failure(DatabaseException("Failed to load item", e)))
            }
    }
    
    override suspend fun addShoppingListItem(item: ShoppingListItem): Result<Long> {
        return try {
            val id = shoppingListDao.insertItem(item.toEntity())
            Result.success(id)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to add item", e))
        }
    }
    
    override suspend fun addShoppingListItems(items: List<ShoppingListItem>): Result<List<Long>> {
        return try {
            val ids = shoppingListDao.insertItems(items.map { it.toEntity() })
            Result.success(ids)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to add items", e))
        }
    }
    
    override suspend fun updateShoppingListItem(item: ShoppingListItem): Result<Unit> {
        return try {
            shoppingListDao.updateItem(item.toEntity())
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to update item", e))
        }
    }
    
    override suspend fun deleteShoppingListItem(id: Long): Result<Unit> {
        return try {
            shoppingListDao.deleteItemById(id)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to delete item", e))
        }
    }
    
    override suspend fun deleteCheckedItems(): Result<Unit> {
        return try {
            shoppingListDao.deleteCheckedItems()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to clear checked items", e))
        }
    }
    
    override suspend fun deleteAutoGeneratedItems(): Result<Unit> {
        return try {
            shoppingListDao.deleteAutoGeneratedItems()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to delete auto-generated items", e))
        }
    }
    
    override suspend fun uncheckAllItems(): Result<Unit> {
        return try {
            shoppingListDao.uncheckAllItems()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(DatabaseException("Failed to uncheck items", e))
        }
    }
}
```

### Mappers

```kotlin
fun ShoppingListItemEntity.toDomainModel(): ShoppingListItem {
    return ShoppingListItem(
        id = id,
        name = name,
        quantity = quantity,
        unit = unit,
        category = ItemCategory.valueOf(category),
        isChecked = isChecked,
        isManual = isManual,
        mealIds = if (mealIds.isBlank()) emptyList() else mealIds.split(",").mapNotNull { it.toLongOrNull() },
        createdAt = createdAt
    )
}

fun ShoppingListItem.toEntity(): ShoppingListItemEntity {
    return ShoppingListItemEntity(
        id = id,
        name = name,
        quantity = quantity,
        unit = unit,
        category = category.name,
        isChecked = isChecked,
        isManual = isManual,
        mealIds = mealIds.joinToString(","),
        createdAt = createdAt
    )
}
```

## UI Layer Design

### UI State Models

```kotlin
// Shopping list screen state
data class ShoppingListUiState(
    val shoppingListData: ShoppingListData? = null,
    val isLoading: Boolean = false,
    val isGenerating: Boolean = false,
    val error: String? = null,
    val showAddItemDialog: Boolean = false,
    val showItemDetail: ShoppingListItem? = null,
    val itemSources: List<IngredientSource> = emptyList(),
    val filterUncheckedOnly: Boolean = false,
    val searchQuery: String = ""
)
```

### ViewModel

```kotlin
@HiltViewModel
class ShoppingListViewModel @Inject constructor(
    private val getShoppingListUseCase: GetShoppingListUseCase,
    private val generateShoppingListUseCase: GenerateShoppingListUseCase,
    private val toggleItemCheckedUseCase: ToggleItemCheckedUseCase,
    private val addManualItemUseCase: AddManualItemUseCase,
    private val updateManualItemUseCase: UpdateManualItemUseCase,
    private val deleteManualItemUseCase: DeleteManualItemUseCase,
    private val clearCheckedItemsUseCase: ClearCheckedItemsUseCase,
    private val uncheckAllItemsUseCase: UncheckAllItemsUseCase,
    private val getItemSourcesUseCase: GetItemSourcesUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ShoppingListUiState())
    val uiState: StateFlow<ShoppingListUiState> = _uiState.asStateFlow()
    
    init {
        loadShoppingList()
    }
    
    private fun loadShoppingList() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            getShoppingListUseCase()
                .catch { e ->
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            error = e.message ?: "Failed to load shopping list"
                        )
                    }
                }
                .collect { result ->
                    result.fold(
                        onSuccess = { data ->
                            _uiState.update { 
                                it.copy(
                                    shoppingListData = data,
                                    isLoading = false,
                                    error = null
                                )
                            }
                        },
                        onFailure = { error ->
                            _uiState.update { 
                                it.copy(
                                    isLoading = false,
                                    error = error.message ?: "Failed to load shopping list"
                                )
                            }
                        }
                    )
                }
        }
    }
    
    fun generateShoppingList() {
        viewModelScope.launch {
            _uiState.update { it.copy(isGenerating = true) }
            
            generateShoppingListUseCase().fold(
                onSuccess = {
                    _uiState.update { it.copy(isGenerating = false) }
                },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(
                            isGenerating = false,
                            error = error.message ?: "Failed to generate shopping list"
                        )
                    }
                }
            )
        }
    }
    
    fun toggleItemChecked(itemId: Long, isChecked: Boolean) {
        viewModelScope.launch {
            toggleItemCheckedUseCase(itemId, isChecked).fold(
                onSuccess = { /* List updates automatically */ },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(error = error.message ?: "Failed to update item")
                    }
                }
            )
        }
    }
    
    fun showAddItemDialog() {
        _uiState.update { it.copy(showAddItemDialog = true) }
    }
    
    fun dismissAddItemDialog() {
        _uiState.update { it.copy(showAddItemDialog = false) }
    }
    
    fun addManualItem(name: String, quantity: String, unit: String) {
        viewModelScope.launch {
            addManualItemUseCase(name, quantity, unit).fold(
                onSuccess = {
                    _uiState.update { it.copy(showAddItemDialog = false) }
                },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(error = error.message ?: "Failed to add item")
                    }
                }
            )
        }
    }
    
    fun showItemDetail(item: ShoppingListItem) {
        viewModelScope.launch {
            if (item.isManual) {
                _uiState.update { 
                    it.copy(
                        showItemDetail = item,
                        itemSources = emptyList()
                    )
                }
            } else {
                getItemSourcesUseCase(item.name, item.mealIds).fold(
                    onSuccess = { sources ->
                        _uiState.update { 
                            it.copy(
                                showItemDetail = item,
                                itemSources = sources
                            )
                        }
                    },
                    onFailure = { error ->
                        _uiState.update { 
                            it.copy(error = error.message ?: "Failed to load item sources")
                        }
                    }
                )
            }
        }
    }
    
    fun dismissItemDetail() {
        _uiState.update { 
            it.copy(
                showItemDetail = null,
                itemSources = emptyList()
            )
        }
    }
    
    fun deleteManualItem(itemId: Long) {
        viewModelScope.launch {
            deleteManualItemUseCase(itemId).fold(
                onSuccess = {
                    _uiState.update { it.copy(showItemDetail = null) }
                },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(error = error.message ?: "Failed to delete item")
                    }
                }
            )
        }
    }
    
    fun clearCheckedItems() {
        viewModelScope.launch {
            clearCheckedItemsUseCase().fold(
                onSuccess = { /* List updates automatically */ },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(error = error.message ?: "Failed to clear checked items")
                    }
                }
            )
        }
    }
    
    fun uncheckAllItems() {
        viewModelScope.launch {
            uncheckAllItemsUseCase().fold(
                onSuccess = { /* List updates automatically */ },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(error = error.message ?: "Failed to uncheck items")
                    }
                }
            )
        }
    }
    
    fun toggleFilter() {
        _uiState.update { it.copy(filterUncheckedOnly = !it.filterUncheckedOnly) }
    }
    
    fun updateSearchQuery(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
    }
    
    fun shareShoppingList() {
        // Generate text representation for sharing
        val data = uiState.value.shoppingListData ?: return
        val text = buildString {
            appendLine("Shopping List")
            appendLine()
            data.itemsByCategory.forEach { (category, items) ->
                val uncheckedItems = items.filter { !it.isChecked }
                if (uncheckedItems.isNotEmpty()) {
                    appendLine(category.displayName())
                    uncheckedItems.forEach { item ->
                        appendLine("  - ${item.name} (${item.quantity} ${item.unit})")
                    }
                    appendLine()
                }
            }
        }
        // Trigger share intent (handled in UI layer)
    }
}
```

### Screen Composables

```kotlin
@Composable
fun ShoppingListScreen(
    viewModel: ShoppingListViewModel = hiltViewModel(),
    onMealDetailClick: (Long) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    
    ShoppingListContent(
        uiState = uiState,
        onItemCheckedChange = viewModel::toggleItemChecked,
        onItemClick = viewModel::showItemDetail,
        onAddItemClick = viewModel::showAddItemDialog,
        onGenerateList = viewModel::generateShoppingList,
        onClearChecked = viewModel::clearCheckedItems,
        onUncheckAll = viewModel::uncheckAllItems,
        onToggleFilter = viewModel::toggleFilter,
        onSearchQueryChange = viewModel::updateSearchQuery,
        onShareList = viewModel::shareShoppingList,
        onMealDetailClick = onMealDetailClick
    )
    
    if (uiState.showAddItemDialog) {
        AddItemDialog(
            onConfirm = viewModel::addManualItem,
            onDismiss = viewModel::dismissAddItemDialog
        )
    }
    
    uiState.showItemDetail?.let { item ->
        ItemDetailDialog(
            item = item,
            sources = uiState.itemSources,
            onDismiss = viewModel::dismissItemDetail,
            onDelete = if (item.isManual) {
                { viewModel.deleteManualItem(item.id) }
            } else null,
            onMealClick = onMealDetailClick
        )
    }
}
